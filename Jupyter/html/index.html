<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IMP Tutorial: IMP spatiotemporal tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="//integrativemodeling.org/mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://integrativemodeling.org/fontawesome6/css/fontawesome.min.css" rel="stylesheet" type="text/css" >
<link href="https://integrativemodeling.org/fontawesome6/css/brands.min.css" rel="stylesheet" type="text/css" >
<link href="https://integrativemodeling.org/imp.css" rel="stylesheet" type="text/css"/>
<link href="https://integrativemodeling.org/tutorials/salilab-doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="impnav">
   <table class="imptnav">
      <tr>
         <td><a href="https://integrativemodeling.org/">
             <img src="https://integrativemodeling.org/images/the_imp.png" height="60" alt="IMP logo" border="0"/></a></td>
         <td>
            <div id="implinks">
             <ul>
               <li><a href="https://integrativemodeling.org/">home</a></li>
               <li><a href="https://integrativemodeling.org/about.html">about</a></li>
               <li><a href="https://integrativemodeling.org/news.html">news</a></li>
               <li><a href="https://integrativemodeling.org/download.html">download</a></li>
               <li><a href="https://integrativemodeling.org/doc.html">doc</a></li>
               <li><a href="https://github.com/salilab/imp">source</a></li>
               <li><a href="https://integrativemodeling.org/systems/">systems</a></li>
               <li><a href="https://integrativemodeling.org/nightly/results/">tests</a></li>
               <li><a href="https://github.com/salilab/imp/issues">bugs</a></li>
               <li><a href="https://integrativemodeling.org/contact.html">contact</a></li>
           </ul>
            </div>
         </td>
      </tr>
   </table>
</div>
<div id="impheaderline">
</div>
  <div id="container">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IMP Tutorial
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div><div class="header">
  <div class="headertitle"><div class="title">IMP spatiotemporal tutorial </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="mainpage"></a></p>
<h1><a class="anchor" id="introduction"></a>
Introduction</h1>
<p>Biomolecules are constantly in motion; therefore, a complete depiction of their function must include their dynamics instead of just static structures. We have developed an integrative spatiotemporal approach to model dynamic systems.</p>
<p>Our approach applies a composite workflow, consisting of three modeling problems to compute (i) heterogeneity models, (ii) snapshot models, and (iii) trajectory models. Heterogeneity models describe the possible biomolecular compositions of the system at each time point. Optionally, other auxiliary variables can be considered, such as the coarse location in the final state when modeling an assembly process. For each heterogeneity model, one snapshot model is produced. A snapshot model is a set of alternative standard static integrative structure models based on the information available for the corresponding time point. Then, trajectory models are created by connecting alternative snapshot models at adjacent time points. These trajectory models can be scored based on both the scores of static structures and the transitions between them, allowing for the creation of trajectories that are in agreement with the input information by construction.</p>
<p>If you use this tutorial or its accompanying method, please site the corresponding publications:</p>
<ul>
<li>Latham, A.P.; Tempkin, J.O.B.; Otsuka, S.; Zhang, W.; Ellenberg, J.; Sali, A. bioRxiv, 2024, <a href="https://doi.org/10.1101/2024.08.06.606842">https://doi.org/10.1101/2024.08.06.606842</a>.</li>
<li>Latham, A.P.; Rožič, M.; Webb, B.M., Sali, A. in preparation. (tutorial)</li>
</ul>
<h1><a class="anchor" id="steps"></a>
Integrative spatiotemporal modeling workflow</h1>
<p>In general, integrative modeling proceeds through three steps (i. gathering information; ii. choosing the model representation, scoring alternative models, and searching for good scoring models; and iii. assessing the models). In integrative spatiotemporal modeling, these three steps are repeated for each modeling problem in the composite workflow (i. modeling of heterogeneity, ii. modeling of snapshots, and iii. modeling of a trajectory).</p>
<p><img src="images/Overview.png" alt="" width="300px" class="inline"/></p>
<p>This tutorial will walk you through the creation of a spatiotemporal model for the hypothetical assembly mechanism of the Bmi1/Ring1b-UbcH5c complex. We note that all experimental data besides the static structure used in this study is purely hypothetical, and, thus, the model should not be interpreted to be meaningful about the actual assembly mechanism of the complex.</p>
<p>Finally, this notebook is intended to present an abbreviated version of this protocol, with the computationally expensive steps excluded. A more complete version of this tutorial can be found as a series of python scripts at <a href="https://github.com/salilab/imp_spatiotemporal_tutorial">https://github.com/salilab/imp_spatiotemporal_tutorial</a>.</p>
<h1><a class="anchor" id="heterogeneity"></a>
Modeling of heterogeneity</h1>
<p>Here, we describe the first modeling problem in our composite workflow, how to build models of heterogeneity modeling using IMP. In this tutorial, heterogeneity modeling only includes protein copy number; however, in general, other types of information, such as the coarse location in the final state, could also be included in heterogeneity models.</p>
<h1><a class="anchor" id="heterogeneity1"></a>
Heterogeneity modeling step 1: gathering of information</h1>
<p>We begin heterogeneity modeling with the first step of integrative modeling, gathering information. Heterogeneity modeling will rely on copy number information about the complex. In this case, we utilize the X-ray crystal structure of the fully assembled Bmi1/Ring1b-UbcH5c complex from the protein data bank (PDB), and synthetically generated protein copy numbers during the assembly process, which could be generated from experiments such as flourescence correlation spectroscopy (FCS).</p>
<p><img src="images/Input_heterogeneity.png" alt="" width="600px" class="inline"/></p>
<p>The PDB structure of the complex informs the final state of our model and constrains the maximum copy number for each protein, while the protein copy number data gives time-dependent information about the protein copy number in the assembling complex.</p>
<h1><a class="anchor" id="heterogeneity2"></a>
Heterogeneity modeling step 2: representation, scoring function, and search process</h1>
<p>Next, we represent, score and search for heterogeneity models models. A single heterogeneity model is a set of protein copy numbers, scored according to its fit to experimental copy number data at that time point. As ET and SAXS data, are only available at 0 minutes, 1 minute, and 2 minutes, we choose to create heterogeneity models at these three time points. We then use <code>prepare_protein_library</code>, to calculate the protein copy numbers for each snapshot model and to use the topology file of the full complex (<code>spatiotemporal_topology.txt</code>) to generate a topology file for each of these snapshot models. The choices made in this topology file are important for the representation, scoring function, and search process for snapshot models, and are discussed later. For heterogeneity modeling, we choose to model 3 protein copy numbers at each time point, and restrict the final time point to have the same protein copy numbers as the PDB structure.</p>
<div class="fragment"><div class="line"><span class="comment"># General imports for the tutorial</span></div>
<div class="line"><span class="keyword">import</span> sys, os, glob, shutil</div>
<div class="line"><span class="keyword">from</span> <a class="code hl_namespaceRef" href="https://integrativemodeling.org/2.21.0/doc/ref/namespaceIMP_1_1spatiotemporal.html">IMP.spatiotemporal</a> <span class="keyword">import</span> prepare_protein_library</div>
<div class="line"><span class="keyword">import</span> <a class="code hl_namespaceRef" href="https://integrativemodeling.org/2.21.0/doc/ref/namespaceIMP_1_1spatiotemporal.html">IMP.spatiotemporal</a> <span class="keyword">as</span> spatiotemporal</div>
<div class="line"><span class="keyword">from</span> <a class="code hl_namespaceRef" href="https://integrativemodeling.org/2.21.0/doc/ref/namespaceIMP_1_1spatiotemporal.html">IMP.spatiotemporal</a> <span class="keyword">import</span> analysis</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="ttc" id="anamespaceIMP_1_1spatiotemporal_html"><div class="ttname"><a href="https://integrativemodeling.org/2.21.0/doc/ref/namespaceIMP_1_1spatiotemporal.html">IMP::spatiotemporal</a></div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment"># parameters for prepare_protein_library:</span></div>
<div class="line">times = [<span class="stringliteral">&quot;0min&quot;</span>, <span class="stringliteral">&quot;1min&quot;</span>, <span class="stringliteral">&quot;2min&quot;</span>]</div>
<div class="line">exp_comp = {<span class="stringliteral">&#39;A&#39;</span>: <span class="stringliteral">&#39;../../../modeling/Input_Information/gen_FCS/exp_compA.csv&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;B&#39;</span>: <span class="stringliteral">&#39;../../../modeling/Input_Information/gen_FCS/exp_compB.csv&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;C&#39;</span>: <span class="stringliteral">&#39;../../../modeling/Input_Information/gen_FCS/exp_compC.csv&#39;</span>}</div>
<div class="line">expected_subcomplexes = [<span class="stringliteral">&#39;A&#39;</span>, <span class="stringliteral">&#39;B&#39;</span>, <span class="stringliteral">&#39;C&#39;</span>]</div>
<div class="line">template_topology = <span class="stringliteral">&#39;spatiotemporal_topology.txt&#39;</span></div>
<div class="line">template_dict = {<span class="stringliteral">&#39;A&#39;</span>: [<span class="stringliteral">&#39;Ubi-E2-D3&#39;</span>], <span class="stringliteral">&#39;B&#39;</span>: [<span class="stringliteral">&#39;BMI-1&#39;</span>], <span class="stringliteral">&#39;C&#39;</span>: [<span class="stringliteral">&#39;E3-ubi-RING2&#39;</span>]}</div>
<div class="line">nmodels = 3</div>
<div class="line"> </div>
<div class="line"><span class="comment"># calling prepare_protein_library</span></div>
<div class="line">prepare_protein_library.prepare_protein_library(times, exp_comp, expected_subcomplexes, nmodels,</div>
<div class="line">                                                template_topology=template_topology, template_dict=template_dict)</div>
</div><!-- fragment --><p> From the output of <code>prepare_protein_library</code>, we see that there are 3 heterogeneity models at each time point (it is possible to have more snapshot models than copy numbers if multiple copies of the protein exist in the complex). For each heterogeneity model, we see 2 files:</p><ul>
<li>*.config, a file with a list of proteins represented in the heterogeneity model</li>
<li>*_topol.txt, a topology file for snapshot modeling corresponding to this heterogeneity model.</li>
</ul>
<h1><a class="anchor" id="heterogeneity_assess"></a>
Heterogeneity modeling step 3: assessment</h1>
<p>Now, we have a variety of heterogeneity models. In general, there are four ways to assess a model: estimate the sampling precision, compare the model to data used to construct it, validate the model against data not used to construct it, and quantify the precision of the model. Here, we will focus specifically on comparing the model to experimental data, as other assessments will be performed later, when the trajectory models are assessed.</p>
<p>Next, we must plot the modeled and experimental copy numbers simultaneously for each protein.</p>
<div class="fragment"><div class="line"><span class="comment">#TODO: plotting script</span></div>
</div><!-- fragment --><p> From these plots, we observe that the range of possible experimental copy numbers are well sampled by the heterogeneity models, indicating that we are prepared for snapshot modeling.</p>
<h1><a class="anchor" id="snapshots"></a>
Modeling of snapshots</h1>
<p>Here, we describe the second modeling problem in our composite workflow, how to build models of static snapshot models using IMP. We note that this process is similar to previous tutorials of <a href="https://integrativemodeling.org/tutorials/actin/">actin</a> and <a href="https://integrativemodeling.org/tutorials/rnapolii_stalk/">RNA PolII</a>.</p>
<h1><a class="anchor" id="snapshots1"></a>
Snapshot modeling step 1: gathering of information</h1>
<p>We begin snapshot modeling with the first step of integrative modeling, gathering information. Snapshot modeling utilizes structural information about the complex. In this case, we utilize heterogeneity models, the X-ray crystal structure of the fully assembled Bmi1/Ring1b-UbcH5c complex from the protein data bank (PDB), synthetically generated electron tomography (ET) density maps during the assembly process, and physical principles.</p>
<p><img src="images/Input_snapshot.png" alt="" width="600px" class="inline"/></p>
<p>The heterogeneity models inform protein copy numbers for the snapshot models. The PDB structure of the complex informs the structure of the individual proteins. The time-dependent ET data informs the size and shape of the assembling complex. physical principles inform connectivity and excluded volume.</p>
<h1><a class="anchor" id="snapshots2"></a>
Snapshot modeling step 2: representation, scoring function, and search process</h1>
<p>Next, we represent, score and search for snapshot models. This step is quite computationally expensive. Therefore, we will not run the modeling protocol in this notebook, though the scripts are available in <code>modeling/Snapshots/Snapshots_Modeling/</code>. Here, we will simply describe the important steps made by two scripts. The first, <code>static_snapshot.py</code>, uses IMP to represent, score, and search for a single static snapshot model. The second, <code>start_sim.py</code>, automates the creation of a snapshot model for each heterogeneity model.</p>
<h2><a class="anchor" id="autotoc1v1"></a>
Modeling one snapshot</h2>
<p>Here, we will describe the process of modeling a single snapshot model, as performed by running <code>static_snapshot.py</code>.</p>
<h3><a class="anchor" id="snapshot_representation"></a>
Representing the model</h3>
<p>We begin by representing the data and the model. In general, the <em>representation</em> of a system is defined by all the variables that need to be determined.</p>
<p>For our model of a protein complex, we use a combination of two representations. The first is a series of <em>spherical beads</em>, which can correspond to portions of the biomolecules of interest, such as atoms or groups of atoms. The second is a series of <em>3D Gaussians</em>, which help calculate the overlap between our model and the density from ET data.</p>
<p>Beads and Gaussians in our model belong to either a <em>rigid body</em> or <em>flexible string</em>. The positions of all beads and Gaussians in a single rigid body are constrained during sampling and do not move relative to each other. Meanwhile, flexible beads can move freely during sampling, but are restrained by sequence connectivity.</p>
<p>To begin, we built a topology file with the representation for the model of the complete system, <code>spatiotemporal_topology.txt</code>, located in <code>Heterogeneity/Heterogeneity_Modeling/</code>. This complete topology was used as a template to build topologies of each heterogeneity model. Based on our observation of the structure of the complex, we chose to represent each protein with at least 2 separate rigid bodies, and left the first 28 residues of protein C as flexible beads. Rigid bodies were described with 1 bead for every residue, and 10 residues per Gaussian. Flexible beads were described with 1 bead for every residue and 1 residue per Gaussian. A more complete description of the options available in topology files is available in the the <a href="https://integrativemodeling.org/2.21.0/doc/ref/classIMP_1_1pmi_1_1topology_1_1TopologyReader.html">TopologyReader</a> documentation.</p>
<div class="fragment"><div class="line">|molecule_name | color | fasta_fn | fasta_id | pdb_fn | chain | residue_range | pdb_offset | bead_size | em_residues_per_gaussian | rigid_body | super_rigid_body | chain_of_super_rigid_bodies | </div>
<div class="line"> </div>
<div class="line">|Ubi-E2-D3|blue|3rpg.fasta.txt|Ubi-E2-D3|3rpg.pdb|A|-1,18|2|1|10|1|1||</div>
<div class="line">|Ubi-E2-D3|blue|3rpg.fasta.txt|Ubi-E2-D3|3rpg.pdb|A|19,147|2|1|10|2|1||</div>
<div class="line">|BMI-1|red|3rpg.fasta.txt|BMI-1|3rpg.pdb|B|3,83|-2|1|10|3|2||</div>
<div class="line">|BMI-1|red|3rpg.fasta.txt|BMI-1|3rpg.pdb|B|84,101|-2|1|10|4|2||</div>
<div class="line">|E3-ubi-RING2|green|3rpg.fasta.txt|E3-ubi-RING2|BEADS|C|16,44|-15|1|1|5|3||</div>
<div class="line">|E3-ubi-RING2|green|3rpg.fasta.txt|E3-ubi-RING2|3rpg.pdb|C|45,116|-15|1|10|6|3||</div>
</div><!-- fragment --><p>Next, we must prepare <code>static_snapshot.py</code> to read in this topology file. We begin by defining the input variables, <code>state</code> and <code>time</code>, which define which topology to use, as well as the paths to other pieces of input information.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">time = sys.argv[2]</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">fasta_dir = <span class="stringliteral">&quot;../../../../Input_Information/FASTA&quot;</span></div>
<div class="line"> </div>
</div><!-- fragment --><p>Next, we build the system, using the topology tile, described above. </p><div class="fragment"><div class="line"> </div>
bs.add_state(t)</div><!-- fragment --><p>Then, we prepare for later sampling steps by setting which Monte Carlo moves will be performed. Rotation (<code>rot</code>) and translation (<code>trans</code>) parameters are separately set for super rigid bodies (<code>srb</code>), rigid bodies (<code>rb</code>), and beads (<code>bead</code>). </p><div class="fragment"><div class="line"> </div>
<div class="line">                                  max_rb_rot=0.5, max_bead_trans=2.0,</div>
<div class="line">                                  max_srb_trans=1.0, max_srb_rot=0.5)</div>
</div><!-- fragment --><h3><a class="anchor" id="snapshot_scoring"></a>
Scoring the model</h3>
<p>After building the model representation, we choose a scoring function to score the model based on input information. This scoring function is represented as a series of restraints that serve as priors.</p>
<h4><a class="anchor" id="autotoc1v12"></a>
Connectivity</h4>
<p>We begin with a connectivity restraint, which restrains beads adjacent in sequence to be close in 3D space.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    cr = <a class="code hl_classRef" href="https://integrativemodeling.org/2.21.0/doc/ref/classIMP_1_1pmi_1_1restraints_1_1stereochemistry_1_1ConnectivityRestraint.html">IMP.pmi.restraints.stereochemistry.ConnectivityRestraint</a>(m)</div>
<div class="line">    cr.add_to_model()</div>
<div class="line">    output_objects.append(cr)</div>
<div class="ttc" id="aclassIMP_1_1pmi_1_1restraints_1_1stereochemistry_1_1ConnectivityRestraint_html"><div class="ttname"><a href="https://integrativemodeling.org/2.21.0/doc/ref/classIMP_1_1pmi_1_1restraints_1_1stereochemistry_1_1ConnectivityRestraint.html">IMP::pmi::restraints::stereochemistry::ConnectivityRestraint</a></div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc1v17"></a>
Excluded volume</h4>
<p>Next is an excluded volume restraint, which restrains beads to minimize their spatial overlap.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">                                     included_objects=[root_hier],</div>
<div class="line">                                     resolution=1000)</div>
<div class="line">output_objects.append(evr)</div>
<div class="line">evr.add_to_model()</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc1v19"></a>
Electron tomography</h4>
<p>Finally, we restrain our models based on their fit to ET density maps. Both the experimental map and the forward protein density are represented as Gaussian mixture models (GMMs) to speed up scoring. The score is based on the log of the correlation coefficient between the experimental density and the forward protein density.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">                 representation_type=IMP.atom.DENSITIES).get_selected_particles()</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        densities,</div>
<div class="line">        target_fn=em_map,</div>
<div class="line">        slope=0.000001,</div>
<div class="line">        scale_target_to_mass=<span class="keyword">True</span>,</div>
<div class="line">        weight=1000)</div>
<div class="line">output_objects.append(emr)</div>
<div class="line">emr.add_to_model()</div>
</div><!-- fragment --><h3><a class="anchor" id="snapshot_searching"></a>
Searching for good scoring models</h3>
<p>After building a scoring function that scores alternative models based on their fit to the input information, we aim to search for good scoring models. For complicated systems, stochastic sampling techniques such as Monte Carlo (MC) sampling are often the most efficient way to compute good scoring models. Here, we generate a random initial configuration and then perform temperature replica exchange MC sampling with 16 temperatures from different initial configurations. By performing multiple runs of replica exchange MC from different initial configurations, we can later ensure that our sampling is sufficiently converged.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">                                    max_translation=50)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        root_hier=root_hier,</div>
<div class="line">        monte_carlo_sample_objects=dof.get_movers(),</div>
<div class="line">        global_output_directory=<span class="stringliteral">&#39;output&#39;</span>, <span class="comment"># name &#39;output&#39; is the best for imp sampcon select_good</span></div>
<div class="line">        output_objects=output_objects,</div>
<div class="line">        monte_carlo_steps=200, <span class="comment"># Number of MC steps between writing frames.</span></div>
<div class="line">        number_of_best_scoring_models=0,</div>
<div class="line">        number_of_frames=500) <span class="comment"># number of frames to be saved</span></div>
<div class="line"> </div>
</div><!-- fragment --><p>After performing sampling, a variety of outputs will be created. These outputs include <code>.rmf</code> files, which contain multi-resolution models output by IMP, and <code>.out</code> files which contains a variety of information about the run such as the value of the restraints and the MC acceptance rate.</p>
<h2><a class="anchor" id="snapshot_combine"></a>
Generalizing modeling to all snapshots</h2>
<p>Next, we will describe the process of computing multiple static snapshot models, as performed by running <code>start_sim.py</code>.</p>
<p>From heterogeneity modeling, we see that there are 3 heterogeneity models at each time point (it is possible to have more snapshot models than copy numbers if multiple copies of the protein exist in the complex), each of which has a corresponding topology file in <code>Heterogeneity/Heterogeneity_Modeling/</code>. We wrote a function, <code>generate_all_snapshots</code>, which creates a directory for each snapshot model, copies the python script and topology file into that directory, and submits a job script to run sampling. The job script will likely need to be customized for the user's computer or cluster.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line">main_dir = os.getcwd()</div>
<div class="line">topol_dir = os.path.join(os.getcwd(), <span class="stringliteral">&#39;../../Heterogeneity/Heterogeneity_Modeling&#39;</span>)</div>
<div class="line">items_to_copy = [<span class="stringliteral">&#39;static_snapshot.py&#39;</span>]  <span class="comment"># additionally we need to copy only specific topology file</span></div>
<div class="line"> </div>
<div class="line">                <span class="stringliteral">&quot;#$ -l h_rt=48:00:00\n\nmodule load Sali\nmodule load imp\nmodule load mpi/openmpi-x86_64\n\n&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;mpirun -np $NSLOTS python3 static_snapshot.py {state} {time}&quot;</span>)</div>
<div class="line">number_of_runs = 50</div>
<div class="line"> </div>
<div class="line"> </div>
</div><!-- fragment --><h1><a class="anchor" id="snapshot_assess"></a>
Snapshot modeling step 3: assessment</h1>
<p>The above code would variety of alternative snapshot models. In general, we would like to assess these models in at least 4 ways: estimate the sampling precision, compare the model to data used to construct it, validate the model against data not used to construct it, and quantify the precision of the model. In this portion of the tutorial, we focus specifically on estimating the sampling precision of the model, while quantitative comparisons between the model and experimental data will be reserved for the final step, when we assess trajectories. Again, this assessment process is quite computationally intensive, so, instead of running the script explicitly, we will walk you through the <code>snapshot_assessment.py</code> script, which is located in the <code>modeling/Snapshots/Snapshots_Assessment</code> folder.</p>
<h2><a class="anchor" id="snapshot_filter"></a>
Filtering good scoring models</h2>
<p>Initially, we want to filter the various alternative structural models to only select those that meet certain parameter thresholds. In this case, we filter the structural models comprising each snapshot model by the median cross correlation with EM data. We note that this filtering criteria is subjective, and developing a Bayesian method to objectively weigh different restraints for filtering remains an interesting future development in integrative modeling.</p>
<p>The current filtering procedure involves three steps. In the first step, we look through the <code>stat.*.out</code> files to write out the cross correlation with EM data for each model, which, in this case, is labeled column <code>3</code>, <code>GaussianEMRestraint_None_CCC</code>. In other applications, the column that corresponds to each type of experimental data may change, depending on the scoring terms for each model. For each snapshot model, a new file is written with this data (<code>{state}_{time}_stat.txt</code>).</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">runs_nr = 50</div>
<div class="line">replica_nr = 16</div>
<div class="line">replica_output_name = <span class="stringliteral">&#39;output&#39;</span></div>
<div class="line">decimals_nr = 16</div>
<div class="line"> </div>
<div class="line">extracting_stat_files(state_dict, runs_nr, replica_nr, replica_output_name, keys_to_extract, decimals_nr)</div>
<div class="line">print(<span class="stringliteral">&quot;extracting_stat_files is DONE&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
</div><!-- fragment --><p>In the second step, we want to determine the median value of EM cross correlation for each snapshot model. We wrote <code>general_rule_calculation</code> to look through the <code>general_rule_column</code> for each <code>{state}_{time}_stat.txt</code> file and determine both the median value and the number of structures generated.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line">general_rule_calculation(state_dict, general_rule_column)</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;general_rule_calculation is DONE&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
</div><!-- fragment --><p>In the third step, we use the <code>imp_sampcon select_good</code> tool to filter each snapshot model, according to the median value determined in the previous step. For each snapshot model, this function produces a file, <code>good_scoring_models/model_ids_scores.txt</code>, which contains the run, replicaID, scores, and sampleID for each model that passes filtering. It also saves RMF files with each model from two independent groups of sampling runs from each snapshot model to <code>good_scoring_models/sample_A</code> and <code>good_scoring_models/sample_B</code>, writes the scores for the two independent groups of sampling runs to <code>good_scoring_models/scoresA.txt</code> and <code>good_scoring_models/scoresB.txt</code>, and writes <code>good_scoring_models/model_sample_ids.txt</code> to connect each model to its division of sampling run. More information on <code>imp_sampcon</code> is available in the analysis portion of the <a href="https://integrativemodeling.org/tutorials/actin/analysis.html">actin tutorial</a>.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;general_rule_filter_independent_samples is DONE&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
</div><!-- fragment --><h2><a class="anchor" id="snapshot_sampling_precision"></a>
Plotting data, clustering models, and determining sampling precision</h2>
<p>Next, scores can be plotted for analysis. Here, we wrote the <code>create_histograms</code> function to run <code>imp_sampcon plot_score</code> so that it plots distributions for various scores of interest. Each of these plots are saved to <code>histograms{state}_{time}/{score}.png</code>, where score is an object listed in the <code>score_list</code>. These plots are useful for debugging the modeling protocol, and should appear roughly Gaussian.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">    <span class="stringliteral">&#39;Total_Score&#39;</span>,</div>
<div class="line">    <span class="stringliteral">&#39;ConnectivityRestraint_Score&#39;</span>,</div>
<div class="line">    <span class="stringliteral">&#39;ExcludedVolumeSphere_Score&#39;</span>,</div>
<div class="line">    <span class="stringliteral">&#39;GaussianEMRestraint_None&#39;</span>,</div>
<div class="line">    <span class="stringliteral">&#39;GaussianEMRestraint_None_CCC&#39;</span></div>
<div class="line">] <span class="comment"># list of histograms we want to create in each histograms{state}_{time} directory</span></div>
<div class="line"> </div>
<div class="line">create_histograms(state_dict, main_dir, score_list)</div>
<div class="line">print(<span class="stringliteral">&quot;create_histograms is DONE&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
</div><!-- fragment --><p>We then check the number of models in each sampling run though our function, <code>count_rows_and_generate_report</code>, which writes the <code>independent_samples_stat.txt</code> file. Empirically, we have found that ensuring the overall number of models in each independent sample after filtering is roughly equal serves a good first check on sampling convergence.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;count_rows_and_generate_report is DONE&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
</div><!-- fragment --><p>Next, we write the density range dictionaries, which are output as <code>{state}_{time}_density_ranges.txt</code>. These dictionaries label each protein in each snapshot model, which will be passed into <code>imp_sampcon</code> to calculate the localization density of each protein.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;create_density_dictionary is DONE&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
</div><!-- fragment --><p>Next, we run <code>imp_sampcon exhaust</code> on each snapshot model. This code performs checks on the exhaustiveness of the sampling. Specifically it analyzes the convergence of the model score, whether the two model sets were drawn from the same distribution, and whether each structural cluster includes models from each sample proportionally to its size. The output for each snapshot model is written out to the <code>exhaust_{state}_{time}</code> folder.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;exhaust is DONE&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
</div><!-- fragment --><p>Plots for determining the sampling precision are shown below for a single snapshot model, 1_2min. (a) Tests the convergence of the lowest scoring model (<code>snapshot_{state}_{time}.Top_Score_Conv.pdf</code>). Error bars represent standard deviations of the best scores, estimated by selecting different subsets of models 10 times. The light-blue line indicates a lower bound reference on the total score. (b) Tests that the scores of two independently sampled models come from the same distribution (<code>snapshot_{state}_{time}.Score_Dist.pdf</code>). The difference between the two distributions, as measured by the KS test statistic (D) and KS test p-value (p) indicates that the difference is both statistically insignificant (p&gt;0.05) and small in magnitude (D&lt;0.3). (c) Determines the structural precision of a snapshot model (<code>snapshot_{state}_{time}.ChiSquare.pdf</code>). RMSD clustering is performed at 1 Å intervals until the clustered population (% clustered) is greater than 80%, and either the χ<sup>2</sup> p-value is greater than 0.05 or Cramer’s V is less than 0.1. The sampling precision is indicated by the dashed black line. (d) Populations from sample 1 and sample 2 are shown for each cluster (<code>snapshot_{state}_{time}.Cluster_Population.pdf</code>).</p>
<p><img src="images/Snapshot_Exhaust.png" alt="" width="600px" class="inline"/></p>
<p>Further structural analysis can be calculated by using the <code>cluster.*</code> files. The <code>cluster.*.{sample}.txt</code> files contain the model number for the models in that cluster, where <code>{sample}</code> indicates which round of sampling the models came from. The <code>cluster.*</code> folder contains an RMF for centroid model of that cluster, along with the localization densities for each protein. The localization densities of each protein from each independent sampling can be compared to ensure independent samplings produce the same results.</p>
<p>Ideally, each of these plots should be checked for each snapshot model. As a way to summarize the output of these checks, we can gather the results of the KS test and the sampling precision test for all snapshot models. This is done by running <code>extract_exhaust_data</code> and <code>save_exhaust_data_as_png</code>, which write <code>KS_sampling_precision_output.txt</code> and <code>KS_sampling_precision_output.png</code>, respectively.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;extract_exhaust_data is DONE&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;save_exhaust_data_as_png is DONE&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
</div><!-- fragment --><p>These codes write a table that include the KS two sample test statistic (D), the KS test p-value, and the sampling precision for each snapshot model, which is replotted below.</p>
<p><img src="images/Snapshot_sampling.png" alt="" width="300px" class="inline"/></p>
<h2><a class="anchor" id="snapshot_visualization"></a>
Visualizing models</h2>
<p>The resulting RMF files and localization densities from this analysis can be viewed in <a href="https://www.rbvi.ucsf.edu/chimera/">UCSF Chimera</a> (version&gt;=1.13) or <a href="https://www.cgl.ucsf.edu/chimerax/">UCSF ChimeraX</a>.</p>
<p>Here, we plotted each centroid model (A - blue, B - orange, and C - purple) from the most populated cluster for each snapshot model and compared that model to the experimental EM profile (gray).</p>
<p><img src="images/static_snapshots_noCC.png" alt="" width="300px" class="inline"/></p>
<p>Finally, now that snapshot models were assessed, we can perform modeling of a trajectory.</p>
<h1><a class="anchor" id="trajectories"></a>
Modeling of a Trajectory</h1>
<p>Here, we describe the final modeling problem in our composite workflow, how to build models of trajectory models using IMP.</p>
<h1><a class="anchor" id="trajectories1"></a>
Trajectory modeling step 1: gathering of information</h1>
<p>We begin trajectory modeling with the first step of integrative modeling, gathering information. Trajectory modeling utilizes dynamic information about the bimolecular process. In this case, we utilize heterogeneity models, snapshot models, physical theories, and synthetically generated small-angle X-ray scattering (SAXS) profiles.</p>
<p><img src="images/Input_trajectories.png" alt="" width="600px" class="inline"/></p>
<p>Heterogeneity models inform the possible compositional states at each time point and measure how well a compositional state agrees with input information. Snapshot models provide structural models for each heterogeneity model and measure how well those structural models agree with input information about their structure. Physical theories of macromolecular dynamics inform transitions between states. SAXS data informs the size and shape of the assembling complex and is left for validation.</p>
<h1><a class="anchor" id="trajectories2"></a>
Trajectory modeling step 2: representation, scoring function, and search process</h1>
<p>Trajectory modeling connects alternative snapshot models at adjacent time points, followed by scoring the trajectory models based on their fit to the input information, as described in full <a href="https://www.biorxiv.org/content/10.1101/2024.08.06.606842v1.abstract">here</a>.</p>
<h2><a class="anchor" id="autotoc1v42"></a>
Background behind integrative spatiotemporal modeling</h2>
<h3><a class="anchor" id="trajectory_representation"></a>
Representing the model</h3>
<p>We choose to represent dynamic processes as a trajectory of snapshot models, with one snapshot model at each time point. In this case, we computed snapshot models at 3 time points (0, 1, and 2 minutes), so a single trajectory model will consist of 3 snapshot models, one at each 0, 1, and 2 minutes. The modeling procedure described here will produce a set of scored trajectory models, which can be displayed as a directed acyclic graph, where nodes in the graph represent the snapshot model and edges represent connections between snapshot models at neighboring time points.</p>
<h3><a class="anchor" id="trajectory_scoring"></a>
Scoring the model</h3>
<p>To score trajectory models, we incorporate both the scores of individual snapshot models, as well as the scores of transitions between them. Under the assumption that the process is Markovian (<em>i.e.</em> memoryless), the weight of a trajectory model takes the form:</p>
<p>$$ W(\chi) \propto \displaystyle\prod^{T}_{t=0} P( X_{N,t}, N_{t} | D_{t}) \cdot \displaystyle\prod^{T-1}_{t=0} W(X_{N,t+1},N_{t+1} | X_{N,t},N_{t}, D_{t,t+1}), $$</p>
<p>where $t$ indexes times from 0 until the final modeled snapshot ($T$); $P(X_{N,t}, N_{t} | D_{t})$ is the snapshot model score; and \(W(X_{N,t+1},N_{t+1} | X_{N,t},N_{t}, D_{t,t+1})\) is the transition score. Trajectory model weights ($W(\chi)$) are normalized so that the sum of all trajectory models' weights is 1.0. Transition scores are currently based on a simple metric that either allows or disallows a transition. Transitions are only allowed if all proteins in the first snapshot model are included in the second snapshot model. In the future, we hope to include more detailed transition scoring terms, which may take into account experimental information or physical models of macromolecular dynamics.</p>
<h3><a class="anchor" id="trajectory_searching"></a>
Searching for good scoring models</h3>
<p>Trajectory models are constructed by enumerating all connections between adjacent snapshot models and scoring these trajectory models according to the equation above. This procedure results in a set of weighted trajectory models.</p>
<h2><a class="anchor" id="autotoc1v43"></a>
Computing trajectory models</h2>
<p>To compute trajectory models, we first copy all necessary files to a new directory, <code>data</code>. These files are (i) <code>{state}_{time}.config</code> files, which include the subcomplexes that are in each state, (ii) <code>{state}_{time}_scores.log</code>, which is a list of all scores of all structural models in that snapshot model, and (iii) <code>exp_comp{prot}.csv</code>, which is the experimental copy number for each protein (<code>{prot}</code>) as a function of time. Here, we copy files related to the snapshots (<code>*.log</code> files) from the <code>modeling</code> directory, as we skipped computing snapshots due to the computational expense.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>merge_scores(fileA, fileB, outputFile):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    For each function merges scoresA.txt and scoresB.txt into {state}_{time}_scores.log</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    :param fileA: path to scoresA.txt</span></div>
<div class="line"><span class="stringliteral">    :param fileB: path to scoresB.txt</span></div>
<div class="line"><span class="stringliteral">    :param outputFile: path to output merged .log file named {state}_{time}_scores.log for each snapshot.</span></div>
<div class="line"><span class="stringliteral">    This type of .log file is used in crete_DAG to generate trajectory model.</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line">    <span class="comment"># open both files, so data can be extracted</span></div>
<div class="line">    <span class="keyword">with</span> open(fileA, <span class="stringliteral">&#39;r&#39;</span>) <span class="keyword">as</span> file_a:</div>
<div class="line">        data_a = file_a.readlines()</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">with</span> open(fileB, <span class="stringliteral">&#39;r&#39;</span>) <span class="keyword">as</span> file_b:</div>
<div class="line">        data_b = file_b.readlines()</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Merge the content of both files</span></div>
<div class="line">    merged_data = data_a + data_b</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Write the merged content into the output file</span></div>
<div class="line">    <span class="keyword">with</span> open(outputFile, <span class="stringliteral">&#39;w&#39;</span>) <span class="keyword">as</span> output:</div>
<div class="line">        output.writelines(merged_data)</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>create_data_and_copy_files(state_dict, custom_source_dir1 = None, custom_source_dir2 = None, custom_source_dir3 = None):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    Copies three types of files important to generate trajectory models:</span></div>
<div class="line"><span class="stringliteral">    -.config files created with start_sim.py in Snapshot_Modeling (source_dir1)</span></div>
<div class="line"><span class="stringliteral">    -time-dependent stoichiometry data for each timepoint. Data should be presented in .csv file. With this function all</span></div>
<div class="line"><span class="stringliteral">    csv file in source_dir2 will be copied. These .csv files will be used in the exp_comp dictionary in create_DAG</span></div>
<div class="line"><span class="stringliteral">    function</span></div>
<div class="line"><span class="stringliteral">    -scoresA and scoresB for each snapshot created with imp sampcon exhaust</span></div>
<div class="line"><span class="stringliteral">    (source_dir1 + snapshot + good_scoring_models) are merged into total score .txt using merge_scores helper function.</span></div>
<div class="line"><span class="stringliteral">    All copied files are gathered in newly created &#39;./data/&#39; directory, where everything is prepared for create_DAG</span></div>
<div class="line"><span class="stringliteral">    function.</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    :param state_dict (dict): state_dict: dictionary that defines the spatiotemporal model.</span></div>
<div class="line"><span class="stringliteral">           The keys are strings that correspond to each time point in the</span></div>
<div class="line"><span class="stringliteral">           stepwise temporal process. Keys should be ordered according to the</span></div>
<div class="line"><span class="stringliteral">           steps in the spatiotemporal process. The values are integers that</span></div>
<div class="line"><span class="stringliteral">           correspond to the number of possible states at that timepoint.</span></div>
<div class="line"><span class="stringliteral">    :param custom_source_dir1 (optional - str): Custom path to heterogeneity modeling dir (heterogeneity_modeling.py),</span></div>
<div class="line"><span class="stringliteral">    to copy .config files</span></div>
<div class="line"><span class="stringliteral">    :param custom_source_dir2 (optional - str): Custom path to stoichiometry data dir</span></div>
<div class="line"><span class="stringliteral">    :param custom_source_dir3 (optional - str): Custom path to snapshot modeling dir (start_sim.py), to copy .config</span></div>
<div class="line"><span class="stringliteral">    files and to access scoresA/scoresB (custom_source_dir3 + snapshot{state}_{time} + &#39;good_scoring_models&#39;)</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Create the destination directory if it does not exist (./data/). Here all the</span></div>
<div class="line">    destination_dir = <span class="stringliteral">&#39;./data/&#39;</span></div>
<div class="line">    os.makedirs(destination_dir, exist_ok=<span class="keyword">True</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Path to heterogeneity modeling dir</span></div>
<div class="line">    <span class="keywordflow">if</span> custom_source_dir1:</div>
<div class="line">        source_dir1 = custom_source_dir1</div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        source_dir1 = <span class="stringliteral">&#39;../../Heterogeneity/Heterogeneity_Modeling/&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Path to stoichiometry data dir</span></div>
<div class="line">    <span class="keywordflow">if</span> custom_source_dir2:</div>
<div class="line">        source_dir2 = custom_source_dir2</div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        source_dir2 = <span class="stringliteral">&#39;../../Input_Information/gen_FCS/&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Path to snapshot modeling dir</span></div>
<div class="line">    <span class="keywordflow">if</span> custom_source_dir3:</div>
<div class="line">        source_dir3 = custom_source_dir3</div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        source_dir3 = <span class="stringliteral">&#39;../../Snapshots/Snapshots_Modeling/&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Copy all .config files from the first source directory to the destination directory</span></div>
<div class="line">    <span class="keywordflow">try</span>:</div>
<div class="line">        <span class="keywordflow">for</span> file_name <span class="keywordflow">in</span> os.listdir(source_dir1):</div>
<div class="line">            <span class="keywordflow">if</span> file_name.endswith(<span class="stringliteral">&#39;.config&#39;</span>):</div>
<div class="line">                full_file_name = os.path.join(source_dir1, file_name)</div>
<div class="line">                <span class="keywordflow">if</span> os.path.isfile(full_file_name):</div>
<div class="line">                    shutil.copy(full_file_name, destination_dir)</div>
<div class="line">        print(<span class="stringliteral">&quot;.config files are copied&quot;</span>)</div>
<div class="line">    <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">        print(f<span class="stringliteral">&quot;.config files cannot be copied. Try do do it manually. Reason for Error: {e}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Copy all .csv stoichiometry files from the second source directory to the destination directory</span></div>
<div class="line">    <span class="keywordflow">try</span>:</div>
<div class="line">        <span class="keywordflow">for</span> file_name <span class="keywordflow">in</span> os.listdir(source_dir2):</div>
<div class="line">            <span class="keywordflow">if</span> file_name.endswith(<span class="stringliteral">&#39;.csv&#39;</span>):</div>
<div class="line">                full_file_name = os.path.join(source_dir2, file_name)</div>
<div class="line">                <span class="keywordflow">if</span> os.path.isfile(full_file_name):</div>
<div class="line">                    shutil.copy(full_file_name, destination_dir)</div>
<div class="line">        print(<span class="stringliteral">&quot;.csv stoichiometry files are copied&quot;</span>)</div>
<div class="line">    <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">        print(f<span class="stringliteral">&quot;.csv stoichiometry files cannot be copied. Try do do it manually. Reason for Error: {e}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Copy scoresA and scoresB from the snapshot_{state}_{time} directories and first source directory path</span></div>
<div class="line">    <span class="keywordflow">for</span> time <span class="keywordflow">in</span> state_dict.keys():</div>
<div class="line">        <span class="keywordflow">for</span> state <span class="keywordflow">in</span> range(1, state_dict[time] + 1):</div>
<div class="line">            dir_name = f<span class="stringliteral">&quot;snapshot{state}_{time}&quot;</span></div>
<div class="line">            good_scoring_path = <span class="stringliteral">&quot;good_scoring_models&quot;</span></div>
<div class="line">            file_a = os.path.join(source_dir3, dir_name, good_scoring_path, <span class="stringliteral">&quot;scoresA.txt&quot;</span>)</div>
<div class="line">            file_b = os.path.join(source_dir3, dir_name, good_scoring_path, <span class="stringliteral">&quot;scoresB.txt&quot;</span>)</div>
<div class="line">            output_file = os.path.join(destination_dir, f<span class="stringliteral">&quot;{state}_{time}_scores.log&quot;</span>) <span class="comment"># name of the output file</span></div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">try</span>:</div>
<div class="line">                <span class="comment"># Ensure the directory exists before try to read/write files</span></div>
<div class="line">                <span class="keywordflow">if</span> os.path.exists(file_a) <span class="keywordflow">and</span> os.path.exists(file_b):</div>
<div class="line">                    merge_scores(file_a, file_b, output_file) <span class="comment"># call helper function to merge files</span></div>
<div class="line">                    print(f<span class="stringliteral">&quot;Scores for snapshot{state}_{time} have been merged and saved&quot;</span>)</div>
<div class="line">                <span class="keywordflow">else</span>:  <span class="comment"># many things can go wrong here, so it is good to know where is the problem</span></div>
<div class="line">                    print(f<span class="stringliteral">&quot;Path doesn&#39;t exist: {source_dir3}&quot;</span>)</div>
<div class="line">                    print(f<span class="stringliteral">&quot;Files not found in directory: {dir_name}&quot;</span>)</div>
<div class="line">                    print(f<span class="stringliteral">&quot;Files not found in directory: {file_a}&quot;</span>)</div>
<div class="line">                    print(f<span class="stringliteral">&quot;Files not found in directory: {file_b}&quot;</span>)</div>
<div class="line">                    print(f<span class="stringliteral">&quot;Output directory doesn&#39;t exist: {destination_dir}&quot;</span>)</div>
<div class="line">            <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">                print(f<span class="stringliteral">&quot;total scores files cannot be copied of merged. Reason for Error: {e}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># copy all the relevant files for create_DAG</span></div>
<div class="line"><span class="comment"># it is important that everything starts from main dir</span></div>
<div class="line">main_dir = os.getcwd()</div>
<div class="line">os.chdir(main_dir)</div>
<div class="line">state_dict = {<span class="stringliteral">&#39;0min&#39;</span>: 3, <span class="stringliteral">&#39;1min&#39;</span>: 3, <span class="stringliteral">&#39;2min&#39;</span>: 1}</div>
<div class="line">create_data_and_copy_files(state_dict, custom_source_dir1=main_dir, custom_source_dir2=<span class="stringliteral">&#39;../../../modeling/Input_Information/gen_FCS/&#39;</span>, custom_source_dir3=<span class="stringliteral">&#39;../../../modeling/Snapshots/Snapshots_Modeling/&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># then trajectory model is created based on the all copied data</span></div>
<div class="line">expected_subcomplexes = [<span class="stringliteral">&#39;A&#39;</span>, <span class="stringliteral">&#39;B&#39;</span>, <span class="stringliteral">&#39;C&#39;</span>]</div>
<div class="line">exp_comp = {<span class="stringliteral">&#39;A&#39;</span>: <span class="stringliteral">&#39;exp_compA.csv&#39;</span>, <span class="stringliteral">&#39;B&#39;</span>: <span class="stringliteral">&#39;exp_compB.csv&#39;</span>, <span class="stringliteral">&#39;C&#39;</span>: <span class="stringliteral">&#39;exp_compC.csv&#39;</span>}</div>
<div class="line">input = <span class="stringliteral">&#39;./data/&#39;</span></div>
<div class="line">output = <span class="stringliteral">&quot;../output/&quot;</span></div>
</div><!-- fragment --><p> Next, we compute the spatiotemporal model. The inputs we included are:</p><ul>
<li>state_dict (dict): a dictionary that defines the spatiotemporal model. Keys are strings for each time point in the spatiotemporal process and values are integers corresponding to the number of snapshot models computed at that time point</li>
<li>out_pdf (bool): whether to write the probability distribution function (pdf).</li>
<li>npaths (int): Number of states two write to a file (path*.txt).</li>
<li>input_dir (str): directory with the input information.</li>
<li>scorestr (str): final characters at the end of the score files.</li>
<li>output_dir (str): directory to which model will be written. Will be created if it does not exist.</li>
<li>spatio_temporal_rule (bool): whether to include our transition scoring term, which enforces that all proteins in the first snapshot model are included in the second snapshot model.</li>
<li>expected_subcomplexes (list): list of string objects, which is the subcomplexes to look when enforcing the spatiotemporal rule. Strings should be substrings of those in <code>{state}_{time}.config</code> files.</li>
<li>score_comp (bool): whether to score the composition of each snapshot model.</li>
<li>exp_comp_map (dictionary): key is a string with the name of each protein that will undergo composition scoring, value is the <code>.csv</code> file with the copy number data for that protein.</li>
<li>draw_dag (bool): whether to write out an image of the directed acyclic graph.</li>
</ul>
<div class="fragment"><div class="line">nodes, graph, graph_prob, graph_scores = spatiotemporal.create_DAG(state_dict, out_pdf=<span class="keyword">True</span>, npaths=3,</div>
<div class="line">                                                                       input_dir=input, scorestr=<span class="stringliteral">&#39;_scores.log&#39;</span>,</div>
<div class="line">                                                                       output_dir=output, spatio_temporal_rule=<span class="keyword">True</span>,</div>
<div class="line">                                                                       expected_subcomplexes=expected_subcomplexes,</div>
<div class="line">                                                                       score_comp=<span class="keyword">True</span>, exp_comp_map=exp_comp,</div>
<div class="line">                                                                       draw_dag=<span class="keyword">True</span>)</div>
</div><!-- fragment --><p> After running <code>spatiotemporal.create_DAG</code>, a variety of outputs are written:</p><ul>
<li><code>cdf.txt</code>: the cumulative distribution function for the set of trajectory models.</li>
<li><code>pdf.txt</code>: the probability distribution function for the set of trajectory models.</li>
<li><code>labeled_pdf.txt</code>: Each row has 2 columns and represents a different trajectory model. The first column labels a single trajectory model as a series of snapshot models, where each snapshot model is written as <code>{state}_{time}|</code> in sequential order. The second column is the probability distribution function corresponding to that trajectory model.</li>
<li><code>dag_heatmap.eps</code> and <code>dag_heatmap</code>: image of the directed acyclic graph from the set of models.</li>
<li><code>path*.txt</code>: files where each row includes a <code>{state}_{time}</code> string, so that rows correspond to the states visited over that trajectory model. Files are numbered from the most likely path to the least likely path.</li>
</ul>
<p>Now that we have a trajectory model, we can plot the directed acyclic graph (left) and the series of centroid models from each snapshot model along the most likely trajectory model (right). Each row corresponds to a different time point in the assembly process (0 min, 1 min, and 2 min). Each node is shaded according to its weight in the final model ($W(X_{N,t}N_{t})$). Proteins are colored as A - blue, B - orange, and C - purple.</p>
<p><img src="images/Spatiotemporal_Model.png" alt="" width="300px" class="inline"/></p>
<div class="image">
<img src="Spatiotemporal_Model.png" alt="" width="600px"/>
</div>
<h1><a class="anchor" id="trajectory_assess"></a>
Trajectory modeling step 3: assessment</h1>
<p>Now that the set of spatiotemporal models has been constructed, we must evaluate these models. We can evaluate these models in at least 4 ways: estimate the sampling precision, compare the model to data used to construct it, validate the model against data not used to construct it, and quantify the precision of the model.</p>
<h2><a class="anchor" id="trajectory_sampling_precision"></a>
Sampling precision</h2>
<p>To begin, we calculate the sampling precision of the models. The sampling precision is calculated by using <code>spatiotemporal.create_DAG</code> to reconstruct the set of trajectory models using 2 independent sets of samplings for snapshot models. Then, the overlap between these snapshot models is evaluated using <code>analysis.temporal_precision</code>, which takes in two <code>labeled_pdf</code> files.</p>
<p>The temporal precision can take values between 1.0 and 0.0, and indicates the overlap between the two models in trajectory space. Hence, values close to 1.0 indicate a high sampling precision, while values close to 0.0 indicate a low sampling precision. Here, the value close to 1.0 indicates that sampling does not affect the weights of the trajectory models.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># 1 - copy_files_for_data (copy all relevant files into &#39;data&#39; directory)</span></div>
<div class="line"><span class="keyword">def </span>copy_files_for_data(state_dict, custom_source_dir1 = None, custom_source_dir2 = None, custom_source_dir3 = None):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    Copies three types of files important to generate trajectory models:</span></div>
<div class="line"><span class="stringliteral">    -.config files created with start_sim.py in Snapshot_Modeling (source_dir1)</span></div>
<div class="line"><span class="stringliteral">    -time-dependent stoichiometry data for each timepoint. Data should be presented in .csv file. With this function all</span></div>
<div class="line"><span class="stringliteral">    csv file in source_dir2 will be copied. These .csv files will be used in the exp_comp dictionary in create_DAG</span></div>
<div class="line"><span class="stringliteral">    function</span></div>
<div class="line"><span class="stringliteral">    -scoresA and scoresB for each snapshot created with imp sampcon exhaust</span></div>
<div class="line"><span class="stringliteral">    (source_dir1 + snapshot + good_scoring_models) are merged into total score .txt using merge_scores helper function.</span></div>
<div class="line"><span class="stringliteral">    All copied files are gathered in newly created &#39;./data/&#39; directory, where everything is prepared for create_DAG</span></div>
<div class="line"><span class="stringliteral">    function.</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    :param state_dict (dict): state_dict: dictionary that defines the spatiotemporal model.</span></div>
<div class="line"><span class="stringliteral">           The keys are strings that correspond to each time point in the</span></div>
<div class="line"><span class="stringliteral">           stepwise temporal process. Keys should be ordered according to the</span></div>
<div class="line"><span class="stringliteral">           steps in the spatiotemporal process. The values are integers that</span></div>
<div class="line"><span class="stringliteral">           correspond to the number of possible states at that timepoint.</span></div>
<div class="line"><span class="stringliteral">    :param custom_source_dir1 (optional - str): Custom path to heterogeneity modeling dir (heterogeneity_modeling.py),</span></div>
<div class="line"><span class="stringliteral">    to copy .config files</span></div>
<div class="line"><span class="stringliteral">    :param custom_source_dir2 (optional - str): Custom path to stoichiometry data dir</span></div>
<div class="line"><span class="stringliteral">    :param custom_source_dir3 (optional - str): Custom path to snapshot modeling dir (start_sim.py), to copy .config</span></div>
<div class="line"><span class="stringliteral">    files and to access scoresA/scoresB (custom_source_dir3 + snapshot{state}_{time} + &#39;good_scoring_models&#39;)</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line">    <span class="comment"># Create the destination directory for all the data copied in this function</span></div>
<div class="line">    destination_dir = <span class="stringliteral">&#39;./data/&#39;</span></div>
<div class="line">    os.makedirs(destination_dir, exist_ok=<span class="keyword">True</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># path to snapshot modeling dir</span></div>
<div class="line">    <span class="keywordflow">if</span> custom_source_dir1:</div>
<div class="line">        source_dir1 = custom_source_dir1</div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        source_dir1 = <span class="stringliteral">&#39;../../Heterogeneity/Heterogeneity_Modeling/&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># path to stoichiometry data dir</span></div>
<div class="line">    <span class="keywordflow">if</span> custom_source_dir2:</div>
<div class="line">        source_dir2 = custom_source_dir1</div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        source_dir2 = <span class="stringliteral">&#39;../../Input_Information/gen_FCS/&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># path to snapshot modeling dir</span></div>
<div class="line">    <span class="keywordflow">if</span> custom_source_dir3:</div>
<div class="line">        source_dir3 = custom_source_dir3</div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        source_dir3 = <span class="stringliteral">&#39;../../Snapshots/Snapshots_Modeling/&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Copy all .config files from the first source directory to the destination directory</span></div>
<div class="line">    <span class="keywordflow">try</span>:</div>
<div class="line">        <span class="keywordflow">for</span> file_name <span class="keywordflow">in</span> os.listdir(source_dir1):</div>
<div class="line">            <span class="keywordflow">if</span> file_name.endswith(<span class="stringliteral">&#39;.config&#39;</span>):</div>
<div class="line">                full_file_name = os.path.join(source_dir1, file_name)</div>
<div class="line">                <span class="keywordflow">if</span> os.path.isfile(full_file_name):</div>
<div class="line">                    shutil.copy(full_file_name, destination_dir)</div>
<div class="line">        print(<span class="stringliteral">&quot;.config files are copied&quot;</span>)</div>
<div class="line">    <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">        print(f<span class="stringliteral">&quot;.config files cannot be copied. Try do do it manually. Reason for Error: {e}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Copy all .csv stoichiometry files from the second source directory to the destination directory</span></div>
<div class="line">    <span class="keywordflow">try</span>:</div>
<div class="line">        <span class="keywordflow">for</span> file_name <span class="keywordflow">in</span> os.listdir(source_dir2):</div>
<div class="line">            <span class="keywordflow">if</span> file_name.endswith(<span class="stringliteral">&#39;.csv&#39;</span>):</div>
<div class="line">                full_file_name = os.path.join(source_dir2, file_name)</div>
<div class="line">                <span class="keywordflow">if</span> os.path.isfile(full_file_name):</div>
<div class="line">                    shutil.copy(full_file_name, destination_dir)</div>
<div class="line">        print(<span class="stringliteral">&quot;.csv stoichiometry files are copied&quot;</span>)</div>
<div class="line">    <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">        print(f<span class="stringliteral">&quot;.csv stoichiometry files cannot be copied. Try do do it manually. Reason for Error: {e}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Copy scoresA and scoresB from the snapshot_{state}_{time} directories and first source directory path</span></div>
<div class="line">    <span class="keywordflow">try</span>:</div>
<div class="line">        <span class="keywordflow">for</span> time <span class="keywordflow">in</span> state_dict.keys():</div>
<div class="line">            <span class="keywordflow">for</span> state <span class="keywordflow">in</span> range(1, state_dict[time] + 1):</div>
<div class="line">                snapshot_dir = os.path.join(source_dir3, f<span class="stringliteral">&#39;snapshot{state}_{time}&#39;</span>)</div>
<div class="line">                good_scoring_models_dir = os.path.join(snapshot_dir, <span class="stringliteral">&#39;good_scoring_models&#39;</span>)</div>
<div class="line">                <span class="keywordflow">if</span> os.path.isdir(good_scoring_models_dir):</div>
<div class="line">                    <span class="keywordflow">for</span> score_file <span class="keywordflow">in</span> [<span class="stringliteral">&#39;scoresA.txt&#39;</span>, <span class="stringliteral">&#39;scoresB.txt&#39;</span>]:</div>
<div class="line">                        full_file_name = os.path.join(good_scoring_models_dir, score_file)</div>
<div class="line">                        <span class="keywordflow">if</span> os.path.isfile(full_file_name):</div>
<div class="line">                            new_file_name = f<span class="stringliteral">&#39;{state}_{time}_{os.path.splitext(score_file)[0]}.log&#39;</span></div>
<div class="line">                            shutil.copy(full_file_name, os.path.join(destination_dir, new_file_name))</div>
<div class="line">                            print(f<span class="stringliteral">&quot;Copied {full_file_name} to {os.path.join(destination_dir, new_file_name)}&quot;</span>)</div>
<div class="line">    <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">        print(f<span class="stringliteral">&quot;scoresA.txt and scoresB.txt cannot be copied. Try do do it manually. Reason for Error: {e}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># copy all the relevant files</span></div>
<div class="line">copy_files_for_data(state_dict, custom_source_dir1=<span class="stringliteral">&#39;../../../modeling/Heterogeneity/Heterogeneity_Modeling/&#39;</span>,</div>
<div class="line">                   custom_source_dir2=<span class="stringliteral">&#39;../../../modeling/Input_Information/gen_FCS/&#39;</span>,</div>
<div class="line">                   custom_source_dir3=<span class="stringliteral">&#39;../../../modeling/Snapshots/Snapshots_Modeling/&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># create two independent DAGs</span></div>
<div class="line">expected_subcomplexes = [<span class="stringliteral">&#39;A&#39;</span>, <span class="stringliteral">&#39;B&#39;</span>, <span class="stringliteral">&#39;C&#39;</span>]</div>
<div class="line">exp_comp = {<span class="stringliteral">&#39;A&#39;</span>: <span class="stringliteral">&#39;exp_compA.csv&#39;</span>, <span class="stringliteral">&#39;B&#39;</span>: <span class="stringliteral">&#39;exp_compB.csv&#39;</span>, <span class="stringliteral">&#39;C&#39;</span>: <span class="stringliteral">&#39;exp_compC.csv&#39;</span>}</div>
<div class="line">input = <span class="stringliteral">&quot;./data/&quot;</span></div>
<div class="line">outputA = <span class="stringliteral">&quot;../output_modelA/&quot;</span></div>
<div class="line">outputB = <span class="stringliteral">&quot;../output_modelB/&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Output from sampling precision and model precision to be saved in united dir: analysis_output_precision</span></div>
<div class="line">analysis_output = <span class="stringliteral">&quot;./analysis_output_precision/&quot;</span></div>
<div class="line">os.makedirs(analysis_output, exist_ok=<span class="keyword">True</span>)</div>
<div class="line"> </div>
<div class="line">nodesA, graphA, graph_probA, graph_scoresA = spatiotemporal.create_DAG(state_dict, out_pdf=<span class="keyword">True</span>, npaths=3,</div>
<div class="line">                                                                        input_dir=input, scorestr=<span class="stringliteral">&#39;_scoresA.log&#39;</span>,</div>
<div class="line">                                                                        output_dir=outputA,</div>
<div class="line">                                                                        spatio_temporal_rule=<span class="keyword">False</span>,</div>
<div class="line">                                                                        expected_subcomplexes=expected_subcomplexes,</div>
<div class="line">                                                                        score_comp=<span class="keyword">True</span>, exp_comp_map=exp_comp,</div>
<div class="line">                                                                        draw_dag=<span class="keyword">False</span>)</div>
<div class="line"> </div>
<div class="line">os.chdir(main_dir)</div>
<div class="line">nodesB, graphB, graph_probB, graph_scoresB = spatiotemporal.create_DAG(state_dict, out_pdf=<span class="keyword">True</span>, npaths=3,</div>
<div class="line">                                                                        input_dir=input, scorestr=<span class="stringliteral">&#39;_scoresB.log&#39;</span>,</div>
<div class="line">                                                                        output_dir=outputB,</div>
<div class="line">                                                                        spatio_temporal_rule=<span class="keyword">False</span>,</div>
<div class="line">                                                                        expected_subcomplexes=expected_subcomplexes,</div>
<div class="line">                                                                        score_comp=<span class="keyword">True</span>, exp_comp_map=exp_comp,</div>
<div class="line">                                                                        draw_dag=<span class="keyword">False</span>)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">analysis.temporal_precision(outputA + <span class="stringliteral">&#39;labeled_pdf.txt&#39;</span>, outputB + <span class="stringliteral">&#39;labeled_pdf.txt&#39;</span>,</div>
<div class="line">                            output_fn=<span class="stringliteral">&#39;.&#39;</span> + analysis_output + <span class="stringliteral">&#39;temporal_precision.txt&#39;</span>)</div>
<div class="line">os.chdir(main_dir)  <span class="comment"># it is crucial that after each step, directory is changed back to main</span></div>
<div class="line">print(<span class="stringliteral">&quot;Step 1: calculation of temporal precision IS COMPLETED&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
</div><!-- fragment --> <h2><a class="anchor" id="trajectory_precision"></a>
Model precision</h2>
<p>Next, we calculate the precision of the model, using <code>analysis.precision</code>. Here, the model precision calculates the number of trajectory models with high weights. The precision ranges from 1.0 to 1/d, where d is the number of trajectory models. Values approaching 1.0 indicate the model set can be described by a single trajectory model, while values close to 1/d indicate that all trajectory models have similar weights.</p>
<p>The <code>analysis.precision</code> function reads in the <code>labeled_pdf</code> of the complete model, and calculates the precision of the model. The value close to 1.0 indicates that the set of models can be sufficiently represented by a single trajectory model.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># precision is calculated from .labeled_pdf.txt in Trajectories_Modeling dir</span></div>
<div class="line">trajectories_modeling_input_dir = <span class="stringliteral">&quot;./output/&quot;</span></div>
<div class="line"> </div>
<div class="line">analysis.precision(trajectories_modeling_input_dir + <span class="stringliteral">&#39;labeled_pdf.txt&#39;</span>, output_fn=analysis_output + <span class="stringliteral">&#39;precision.txt&#39;</span>)</div>
<div class="line"> </div>
<div class="line">os.chdir(main_dir)  <span class="comment"># it is crucial that after each step, directory is changed back to main</span></div>
<div class="line">print(<span class="stringliteral">&quot;Step 2: calculation of precision of the model IS COMPLETED&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
</div><!-- fragment --> <h2><a class="anchor" id="trajectory_comparison"></a>
Comparison against data used in model construction</h2>
<p>We then evaluate the model against data used in model construction. First, we can calculate the cross-correlation between the original EM map and the forward density projected from each snapshot model. This calculation is too computationally expensive for this notebook, but can be found in <code>modeling/Trajectories/Trajectories_Assessment</code>, where we wrote the <code>ccEM</code> function to perform this comparison for all snapshot models.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">ccEM(exp_mrc_base_path)</div>
<div class="line">print(<span class="stringliteral">&quot;Step 3a: ET validation IS COMPLETED&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
</div><!-- fragment --><p>The results of this comparison are shown below.</p>
<p>After comparing the model to EM data, we aimed to compare the model to copy number data, and wrote the <code>forward_model_copy_number</code> function to evaluate the copy numbers from our set of trajectory models. The output of <code>forward_model_copy_number</code> is written in <code>forward_model_copy_number/</code>. The folder contains <code>CN_prot_{prot}.txt</code> files for each protein, which have the mean and standard deviation of protein copy number at each time point. We can then plot these copy numbers from the forward models against those from the experiment, as shown below.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>read_labeled_pdf(pdf_file):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    Function to read in a labeled probability distribution file output by spatiotemporal.create_DAG.</span></div>
<div class="line"><span class="stringliteral">    Used to determine protein copy numbers by forward_model_copy_number.</span></div>
<div class="line"><span class="stringliteral">    :param pdf_file (str): sting for the path of the labeled probability distribution file output by</span></div>
<div class="line"><span class="stringliteral">    spatiotemporal.create_DAG.</span></div>
<div class="line"><span class="stringliteral">    :return prob_dict (dict): dictionary defining the spatiotemporal model. Each key is a state, and each value is the</span></div>
<div class="line"><span class="stringliteral">    probability of that state.</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line">    <span class="comment"># create blank dictonary to store the results</span></div>
<div class="line">    prob_dict = {}</div>
<div class="line">    <span class="comment"># read in labeled pdf file</span></div>
<div class="line">    old = open(pdf_file, <span class="stringliteral">&#39;r&#39;</span>)</div>
<div class="line">    line = old.readline()</div>
<div class="line">    <span class="comment"># store the path through various nodes, as well as the probability of that path</span></div>
<div class="line">    <span class="keywordflow">while</span> line:</div>
<div class="line">        line_split = line.split()</div>
<div class="line">        <span class="comment"># assumes the first string is the trajectory string, the second string is the probability</span></div>
<div class="line">        <span class="keywordflow">if</span> len(line_split) &gt; 1:</div>
<div class="line">            <span class="comment"># use # for comments</span></div>
<div class="line">            <span class="keywordflow">if</span> line_split[0]==<span class="stringliteral">&#39;#&#39;</span>:</div>
<div class="line">                <span class="keywordflow">pass</span></div>
<div class="line">            <span class="keywordflow">else</span>:</div>
<div class="line">                trj = line_split[0]</div>
<div class="line">                prob = float(line_split[1])</div>
<div class="line">                <span class="comment"># store in dictionary</span></div>
<div class="line">                prob_dict[trj] = prob</div>
<div class="line">        line = old.readline()</div>
<div class="line">    old.close()</div>
<div class="line">    <span class="keywordflow">return</span> prob_dict</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>copy_number_from_state(prot_list,trj,custom_data_folder = None):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    For a trajectory, returns an array of protein copy numbers as a function of time. Used by</span></div>
<div class="line"><span class="stringliteral">    forward_model_copy_number().</span></div>
<div class="line"><span class="stringliteral">    :param prot_list (list): list of proteins in the model. These proteins are searched for in each config file.</span></div>
<div class="line"><span class="stringliteral">    :param trj (str): string defining a single trajectory.</span></div>
<div class="line"><span class="stringliteral">    :param custom_data_folder (str, optional): path to custom data folder. Defaults to None, which points to &#39;../data/&#39;</span></div>
<div class="line"><span class="stringliteral">    :return _prots (array): 2D array of protein copy numbers. The first index loops over the time,</span></div>
<div class="line"><span class="stringliteral">    while the second index value loops over the protein (ordered as A, B, C).</span></div>
<div class="line"><span class="stringliteral">    :return N (int): Number of time points in each trajectory.</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line">    <span class="comment"># find folder with config files</span></div>
<div class="line">    <span class="keywordflow">if</span> custom_data_folder:</div>
<div class="line">        data_folder = custom_data_folder</div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        data_folder = <span class="stringliteral">&#39;data/&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># split the trajectory into a list of individual states</span></div>
<div class="line">    state_list=trj.split(<span class="stringliteral">&#39;|&#39;</span>)</div>
<div class="line">    state_list=state_list[:-1]</div>
<div class="line"> </div>
<div class="line">    N = len(state_list)</div>
<div class="line">    <span class="comment"># Map from index to protein: 0 - A, 1- B, 2- C</span></div>
<div class="line">    _prots = np.zeros((N, len(prot_list)))</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Grab _prots from .config file</span></div>
<div class="line">    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(0, N):</div>
<div class="line">        prot_file = data_folder + state_list[i] + <span class="stringliteral">&#39;.config&#39;</span></div>
<div class="line">        to_read = open(prot_file, <span class="stringliteral">&#39;r&#39;</span>)</div>
<div class="line">        line = to_read.readline()</div>
<div class="line">        <span class="keywordflow">while</span> line:</div>
<div class="line">            <span class="comment"># for each line, check if the protein is in that line</span></div>
<div class="line">            <span class="keywordflow">for</span> prot_index <span class="keywordflow">in</span> range(len(prot_list)):</div>
<div class="line">                <span class="keywordflow">if</span> prot_list[prot_index] <span class="keywordflow">in</span> line:</div>
<div class="line">                    _prots[i, prot_index] += 1</div>
<div class="line">            line = to_read.readline()</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> _prots,N</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>forward_model_copy_number(prot_list,custom_labeled_pdf=None):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    Code to perform copy number analysis on each protein in the model. Writes output files where each row is ordered</span></div>
<div class="line"><span class="stringliteral">    according to the time point in the model and the first column is the mean copy number, while the second column is</span></div>
<div class="line"><span class="stringliteral">    the standard deviation in copy number.</span></div>
<div class="line"><span class="stringliteral">    :param prot_list (list): list of proteins in the model. These proteins are searched for in each config file.</span></div>
<div class="line"><span class="stringliteral">    :param custom_labeled_pdf (str, optional): path to custom labeled probability distribution file output by</span></div>
<div class="line"><span class="stringliteral">    spatiotemporal.create_DAG.</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line">    <span class="comment"># find folder with config files</span></div>
<div class="line">    <span class="keywordflow">if</span> custom_labeled_pdf:</div>
<div class="line">        _labeled_pdf = custom_data_folder</div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        _labeled_pdf = <span class="stringliteral">&#39;../Trajectories_Modeling/output/labeled_pdf.txt&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Read in labeled_pdf file into a dictionary. Each trajectory is listed as a dictionary,</span></div>
<div class="line">    <span class="comment"># with keys as the trajectory and the values as the probability of that trajectory</span></div>
<div class="line">    prob_dict = read_labeled_pdf(_labeled_pdf)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Loop over the full dictionary. Create a list with 2 values:</span></div>
<div class="line">    <span class="comment"># 1) the probability of the state, 2) the protein copy number of that state.</span></div>
<div class="line">    key_list = prob_dict.keys()</div>
<div class="line">    prot_prob = []</div>
<div class="line">    <span class="keywordflow">for</span> key <span class="keywordflow">in</span> key_list:</div>
<div class="line">        CN,N_times = copy_number_from_state(prot_list,key)</div>
<div class="line">        prot_prob.append([prob_dict[key], CN])</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Construct the full path to the output directory</span></div>
<div class="line">    dir_name = <span class="stringliteral">&quot;forward_model_copy_number&quot;</span></div>
<div class="line">    full_path = os.path.join(main_dir, dir_name)</div>
<div class="line">    os.makedirs(full_path, exist_ok=<span class="keyword">True</span>)</div>
<div class="line">    os.chdir(full_path)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Determine copy number from the prot_prob</span></div>
<div class="line">    <span class="keywordflow">for</span> index <span class="keywordflow">in</span> range(len(prot_prob[0][1][0])):</div>
<div class="line">        copy_number = np.zeros((N_times, 2))</div>
<div class="line">        <span class="comment"># calculate mean</span></div>
<div class="line">        <span class="keywordflow">for</span> state <span class="keywordflow">in</span> prot_prob:</div>
<div class="line">            <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(N_times):</div>
<div class="line">                copy_number[i, 0] += state[0] * state[1][i][index]</div>
<div class="line">        <span class="comment"># calculate std deviation</span></div>
<div class="line">        <span class="keywordflow">for</span> state <span class="keywordflow">in</span> prot_prob:</div>
<div class="line">            <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(N_times):</div>
<div class="line">                <span class="comment"># Calculate variance</span></div>
<div class="line">                copy_number[i, 1] += state[0] * ((state[1][i][index] - copy_number[i, 0]) ** 2)</div>
<div class="line">        <span class="comment"># Take square root to get the standard deviation</span></div>
<div class="line">        copy_number[:, 1] = np.sqrt(copy_number[:, 1])</div>
<div class="line">        <span class="comment"># save to file</span></div>
<div class="line">        np.savetxt(<span class="stringliteral">&#39;CN_prot_&#39;</span>+prot_list[index]+<span class="stringliteral">&#39;.txt&#39;</span>, copy_number, header=<span class="stringliteral">&#39;mean CN\tstd CN&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 3b - comparison of the model to data used in modeling (copy number)</span></div>
<div class="line">os.chdir(main_dir)  <span class="comment"># it is crucial that after each step, directory is changed back to main</span></div>
<div class="line">forward_model_copy_number(expected_subcomplexes)</div>
<div class="line">print(<span class="stringliteral">&quot;Step 3b: copy number validation IS COMPLETED&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
</div><!-- fragment --><p> Here, we plot the comparison between the experimental data used in model construction and the set of trajectory models. This analysis includes the cross-correlation coefficient between the experimental EM density and the forward density of the set of sufficiently good scoring modeled structures in the highest weighted trajectory model (a), as well as comparisons between experimental and modeled protein copy numbers for proteins A (b), B (c), and C (d). Here, we see the model is in good agreement with the data used to construct it.</p>
<p><img src="images/Spatiotemporal_Assessment_Included.png" alt="" width="600px" class="inline"/></p>
<h2><a class="anchor" id="trajectory_validation"></a>
Validation against data not used in model construction</h2>
<p>Finally, we aim to compare the model to data not used in model construction. Specifically, we reserved SAXS data for model validation. We aimed to compare the forward scattering profile from the centroid structural model of each snapshot model to the experimental profile. To make this comparison, we wrote functions that converted each centroid RMF to a PDB (<code>convert_rmfs</code>), copied the experimental SAXS profiles to the appropriate folder (<code>copy_SAXS_dat_files</code>), and ran <a href="https://integrativemodeling.org/tutorials/foxs/foxs.html">FoXS</a> on each PDB to evaluate its agreement to the experimental profile (<code>process_foxs</code>).</p>
<div class="fragment"><div class="line"><span class="comment"># 4a - SAXS</span></div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">Comparing center models of the most dominant cluster for each snapshot (rmfs) to the SAXS data for each time point</span></div>
<div class="line"><span class="stringliteral"> can be done in two steps:</span></div>
<div class="line"><span class="stringliteral">-converting rmfs to pdb files</span></div>
<div class="line"><span class="stringliteral">-comparing pdbs of each snapshot to experimental SAXS profile using FoXS</span></div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>convert_rmfs(state_dict, model, custom_path=None):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    The purpose of this function is to automate the conversion of RMF files into PDB files for all the states from</span></div>
<div class="line"><span class="stringliteral">    state_dict. Created PDBs are further used in comparison of SAXS profiles using FoXS. Additionally, they can be</span></div>
<div class="line"><span class="stringliteral">    used for comparison to native PDB if available.</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    :param state_dict (dict): dictionary that defines the spatiotemporal model.</span></div>
<div class="line"><span class="stringliteral">           The keys are strings that correspond to each time point in the</span></div>
<div class="line"><span class="stringliteral">           stepwise temporal process. Keys should be ordered according to the</span></div>
<div class="line"><span class="stringliteral">           steps in the spatiotemporal process. The values are integers that</span></div>
<div class="line"><span class="stringliteral">           correspond to the number of possible states at that timepoint.</span></div>
<div class="line"><span class="stringliteral">    :param model (str): An IMP (Integrative Modeling Platform) model object.</span></div>
<div class="line"><span class="stringliteral">    :param custom_path (optional - str): A custom path for the RMF file, allowing for flexibility in file location</span></div>
<div class="line"><span class="stringliteral">    (should be compliant with stat_dict).</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> time <span class="keywordflow">in</span> state_dict.keys():</div>
<div class="line">        <span class="keywordflow">for</span> state <span class="keywordflow">in</span> range(1, state_dict[time] + 1):</div>
<div class="line">            <span class="keywordflow">if</span> custom_path:</div>
<div class="line">                sim_rmf = custom_path <span class="comment"># option for custom path</span></div>
<div class="line">            <span class="keywordflow">else</span>:</div>
<div class="line">                sim_rmf = f<span class="stringliteral">&quot;../../../../modeling/Snapshots/Snapshots_Assessment/exhaust_{state}_{time}/cluster.0/cluster_center_model.rmf3&quot;</span></div>
<div class="line"> </div>
<div class="line">            pdb_output = f<span class="stringliteral">&quot;snapshot{state}_{time}.pdb&quot;</span> <span class="comment"># define the output of converted .pdb file</span></div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> os.path.exists(sim_rmf):</div>
<div class="line">                <span class="keywordflow">try</span>:</div>
<div class="line">                    rmf_fh = RMF.open_rmf_file_read_only(sim_rmf) <span class="comment"># open rmf file for reading</span></div>
<div class="line">                    rmf_hierarchy = IMP.rmf.create_hierarchies(rmf_fh, model)[0] <span class="comment"># extract 1st hierarchy</span></div>
<div class="line">                    IMP.atom.write_pdb_of_c_alphas(rmf_hierarchy, pdb_output) <span class="comment"># write coordinates of CA to .pdb</span></div>
<div class="line">                    print(f<span class="stringliteral">&quot;Finishing: snapshot{state}_{time}.pdb&quot;</span>)</div>
<div class="line">                <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">                    print(f<span class="stringliteral">&quot;{sim_rmf} is empty or there is another problem: {e}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>copy_SAXS_dat_files(custom_src_dir = None):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    Copies all files ending with .dat from the specified directory to the current directory.</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    :param custom_src_dir (optional - str): Path to the source directory</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line">    <span class="keywordflow">if</span> custom_src_dir:</div>
<div class="line">        src_dir = custom_src_dir</div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        src_dir = <span class="stringliteral">&#39;../../../Input_Information/gen_SAXS&#39;</span></div>
<div class="line">    <span class="keywordflow">try</span>:</div>
<div class="line">        files = os.listdir(src_dir) <span class="comment"># Get the list of all files in the src_dir directory</span></div>
<div class="line">        dat_files = [f <span class="keywordflow">for</span> f <span class="keywordflow">in</span> files <span class="keywordflow">if</span> f.endswith(<span class="stringliteral">&#39;.dat&#39;</span>)] <span class="comment"># Filter out files that end with .dat</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Copy each .dat file to the current directory, so FoXS can be used</span></div>
<div class="line">        <span class="keywordflow">for</span> file_name <span class="keywordflow">in</span> dat_files:</div>
<div class="line">            full_file_name = os.path.join(src_dir, file_name)</div>
<div class="line">            <span class="keywordflow">if</span> os.path.isfile(full_file_name):</div>
<div class="line">                shutil.copy(full_file_name, os.getcwd())</div>
<div class="line">                <span class="comment"># print(f&quot;Copied: {full_file_name} to {main_dir}&quot;)</span></div>
<div class="line"> </div>
<div class="line">        print(<span class="stringliteral">&quot;All .dat files have been copied successfully...&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">        print(f<span class="stringliteral">&quot;An error occurred: {e}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>process_foxs(state_dict, custom_dat_file = None):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    This function automates the FoXS analysis for all specified time points in a single execution. It processes PDB</span></div>
<div class="line"><span class="stringliteral">    files generated by the convert_rmfs function and uses SAXS data copied with the copy_SAXS function. All of this</span></div>
<div class="line"><span class="stringliteral">    data should be present in the current running directory.</span></div>
<div class="line"><span class="stringliteral">    FoXS tutorial is available here: https://integrativemodeling.org/tutorials/foxs/foxs.html</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    :param state_dict (dict): dictionary that defines the spatiotemporal model.</span></div>
<div class="line"><span class="stringliteral">           The keys are strings that correspond to each time point in the</span></div>
<div class="line"><span class="stringliteral">           stepwise temporal process. Keys should be ordered according to the</span></div>
<div class="line"><span class="stringliteral">           steps in the spatiotemporal process. The values are integers that</span></div>
<div class="line"><span class="stringliteral">           correspond to the number of possible states at that timepoint.</span></div>
<div class="line"><span class="stringliteral">    :param custom_dat_file (optional - str)): A custom name of SAXS files for each time point (should be</span></div>
<div class="line"><span class="stringliteral">    compliant with stat_dict)</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    print(<span class="stringliteral">&quot;...lets proceed to FoXS&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> time <span class="keywordflow">in</span> state_dict.keys():</div>
<div class="line">        <span class="keywordflow">try</span>:</div>
<div class="line">            <span class="keywordflow">if</span> state_dict[time] &gt; 1:</div>
<div class="line">                <span class="comment"># if there is more than one state in timepoint, FoXS creates fit.plt and it should be renamed</span></div>
<div class="line">                <span class="keywordflow">if</span> custom_dat_file:</div>
<div class="line">                    dat_file = custom_dat_file</div>
<div class="line">                <span class="keywordflow">else</span>:</div>
<div class="line">                    dat_file = f<span class="stringliteral">&quot;{time}_exp.dat&quot;</span></div>
<div class="line"> </div>
<div class="line">                pdb_files = <span class="stringliteral">&quot; &quot;</span>.join([f<span class="stringliteral">&quot;snapshot{state}_{time}.pdb&quot;</span> <span class="keywordflow">for</span> state <span class="keywordflow">in</span> range(1, state_dict[time] + 1)])</div>
<div class="line"> </div>
<div class="line">                command1 = f<span class="stringliteral">&quot;foxs -r -g {pdb_files} {dat_file}&quot;</span></div>
<div class="line">                <span class="comment"># example how FoXS command should look like: foxs -r -g snapshot1_0min.pdb snapshot2_0min.pdb snapshot3_0min.pdb 0min_exp.dat</span></div>
<div class="line">                os.system(command1)</div>
<div class="line">                print(f<span class="stringliteral">&quot;FoXS for {time} is calculated and ready to create a plot. Nr of states is: {state_dict[time]}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">                command2 = f<span class="stringliteral">&quot;gnuplot fit.plt&quot;</span> <span class="comment"># create plot from .plt code</span></div>
<div class="line">                os.system(command2)</div>
<div class="line"> </div>
<div class="line">                command3 = f<span class="stringliteral">&quot;mv fit.plt {time}_FoXS.plt&quot;</span> <span class="comment"># rename .plt to avoid to be overwritten</span></div>
<div class="line">                os.system(command3)</div>
<div class="line"> </div>
<div class="line">                command4 = f<span class="stringliteral">&quot;mv fit.png {time}_FoXS.png&quot;</span> <span class="comment"># rename plot to avoid to be overwritten</span></div>
<div class="line">                os.system(command4)</div>
<div class="line"> </div>
<div class="line">                print(f<span class="stringliteral">&quot;Plot {time}_FoXS.png is created&quot;</span>)</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">elif</span> state_dict[time] == 1:</div>
<div class="line">                print(f<span class="stringliteral">&quot;There is only one state in {time}&quot;</span>)</div>
<div class="line">                dat_file1 = f<span class="stringliteral">&quot;{time}_exp.dat&quot;</span></div>
<div class="line">                pdb_file1 = f<span class="stringliteral">&quot;snapshot1_{time}.pdb&quot;</span></div>
<div class="line"> </div>
<div class="line">                command5 = f<span class="stringliteral">&quot;foxs -r -g {pdb_file1} {dat_file1}&quot;</span></div>
<div class="line">                os.system(command5)</div>
<div class="line">                print(f<span class="stringliteral">&quot;FoXS for {time} is calculated and ready to create a plot. Nr of states is: {state_dict[time]}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">                command6 = f<span class="stringliteral">&quot;gnuplot snapshot1_{time}_{time}_exp.plt&quot;</span></div>
<div class="line">                os.system(command6)</div>
<div class="line"> </div>
<div class="line">                command7 = f<span class="stringliteral">&quot;mv snapshot1_{time}_{time}_exp.plt {time}_FoXS.plt&quot;</span></div>
<div class="line">                os.system(command7)</div>
<div class="line"> </div>
<div class="line">                command8 = f<span class="stringliteral">&quot;mv snapshot1_{time}_{time}_exp.png {time}_FoXS.png&quot;</span></div>
<div class="line">                os.system(command8)</div>
<div class="line">            <span class="keywordflow">else</span>:</div>
<div class="line">                print(f<span class="stringliteral">&quot;There is no states in this timepoint. Check stat_dict.&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">            print(f<span class="stringliteral">&quot;FoXS can not be executed properly due to following problem: {e}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># 4a - SAXS</span></div>
<div class="line">os.chdir(main_dir)  <span class="comment"># it is crucial that after each step, directory is changed back to main</span></div>
<div class="line">SAXS_output = <span class="stringliteral">&quot;./SAXS_comparison/&quot;</span></div>
<div class="line">os.makedirs(SAXS_output, exist_ok=<span class="keyword">True</span>)</div>
<div class="line">os.chdir(SAXS_output)</div>
<div class="line">convert_rmfs(state_dict, model)</div>
<div class="line">copy_SAXS_dat_files(custom_src_dir=<span class="stringliteral">&#39;../../../../modeling/Input_Information/gen_SAXS&#39;</span>)</div>
<div class="line">process_foxs(state_dict)</div>
<div class="line">print(<span class="stringliteral">&quot;Step 4a: SAXS validation IS COMPLETED&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
</div><!-- fragment --><p> The output of this analysis is written to <code>SAXS_comparison</code>. Standard FoXS outputs are available for each snapshot model (<code>snapshot{state}_{time}.*</code>). In particular, the <code>.fit</code> files include the forward and experimental profiles side by side, with the $\chi^2$ for the fit. Further, the <code>{time}_FoXS.*</code> files include the information for all snapshot models at that time point, including plots of each profile in comparison to the experimental profile (<code>{time}_FoXS.png</code>).</p>
<p>As our model was generated from synthetic data, the ground truth structure is known at each time point. In addition to validating the model by assessing its comparison to SAXS data, we could approximate the model accuracy by comparing the snapshot model to the PDB structure, although this comparison is not perfect as the PDB structure was used to inform the structure of <em>rigid bodies</em> in the snapshot model. To do so, we wrote a function (<code>RMSD</code>) that calculates the RMSD between each structural model and the orignal PDB. The function is too computationally expensive to run in this notebook, but is found in the <code>Trajectories/Trajectories_Assessment/</code> folder and is demonstrated below.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">pdb_path = <span class="stringliteral">&quot;../../Input_Information/PDB/3rpg.pdb&quot;</span></div>
<div class="line">RMSD(pdb_path=pdb_path, custom_n_plot=20)</div>
<div class="line">print(<span class="stringliteral">&quot;Step 4b: RMSD validation IS COMPLETED&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
</div><!-- fragment --><p>The output of this function is written in <code>RMSD_calculation_output</code>. The function outputs <code>rmsd_{state}_{time}.png</code> files, which plots the RMSD for each structural model within each snapshot model. This data is then summarized in <code>RMSD_analysis.txt</code>, which includes the minimum RMSD, average RMSD, and number of structural models in each snapshot model.</p>
<p>Finally, we plot the results for assessing the spatiotemporal model with data not used to construct it. Comparisons are made between the centroid structure of the most populated cluster in each snapshot model at each time point and the experimental SAXS profile for 0 (a), 1 (b), and 2 (c) minutes. Further, we plot both the sampling precision (dark red) and the RMSD to the PDB structure (light red) for each snapshot model in the highest trajectory model (d).</p>
<p><img src="images/Spatiotemporal_Assessment_Unused.png" alt="" width="600px" class="inline"/></p>
<p>To quantitatively compare the model to SAXS data, we used the $\chi^2$ to compare each snapshot model to the experimental profile. We note that the $\chi^2$ are substantially lower for the models along the highest trajectory model (1_0min, 1_1min, and 1_2min) than for other models, indicating that the highest weighted trajectory model is in better agreement with the experimental SAXS data than other possible trajectory models.</p>
<p><img src="images/Chi2_Table.png" alt="" width="300px" class="inline"/></p>
<p>Next, we can evaluate the accuracy of the model by comparing the RMSD to the PDB to the sampling precision of each snapshot model. We note that this is generally not possible, because in most biological applications the ground truth is not known. In this case, if the average RMSD to the PDB structure is smaller than the sampling precision, the PDB structure lies within the precision of the model. We find that the RMSD is within 1.5 Å of the sampling precision at all time points, indicating that the model lies within 1.5 Å of the ground truth.</p>
<h1><a class="anchor" id="Conclusion"></a>
Next steps</h1>
<p>After assessing our model, we can must decide if the model is sufficient to answer biological questions of interest. If the model does not have sufficient precision for the desired application, assessment of the current model can be used to inform which new experiments may help improve the next iteration of the model. The <a href="https://integrativemodeling.org/tutorials/spatiotemporal/index.html#steps">integrative spatiotemporal modeling procedure</a> can then be repeated iteratively, analogous to <a href="https://integrativemodeling.org/2.21.0/doc/manual/intro.html#procedure">integrative modeling of static structures</a>.</p>
<p>If the model is sufficient to provide insight into the biological process of interest, the user may decide that it is ready for publication. In this case, the user should create an <a href="https://mmcif.wwpdb.org/">mmCIF file</a> to deposit the model in the <a href="https://pdb-dev.wwpdb.org/">PDB-dev database</a>. This procedure is explained in the <a href="https://integrativemodeling.org/tutorials/deposition/develop/">deposition tutorial</a>. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"/>
</div><!-- contents -->
</div>
<!-- start footer part -->
<hr class="footer"/>
<script type='text/javascript'>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44570008-3', 'salilab.org');
  ga('send', 'pageview');
</script>
</body>
</html>
